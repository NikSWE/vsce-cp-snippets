{
  "Creates a quick start template": {
    "prefix": "cpst",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define fastio                        \\",
      "    ios_base::sync_with_stdio(false); \\",
      "    cin.tie(NULL)",
      "",
      "#define endl \"\\n\"",
      "",
      "using namespace std;",
      "",
      "int main()",
      "{",
      "    fastio;",
      "    ${1:// code goes here}",
      "    return 0;",
      "}"
    ],
    "description": "Creates a quick start template"
  },
  "Input test cases": {
    "prefix": "cptc",
    "body": [
      "int ${1:t};",
      "cin >> ${1:t};",
      "",
      "while(${1:t}--)",
      "{",
      "   ${2:// code goes here}",
      "}"
    ],
    "description": "Input test cases"
  },

  "Segment Tree(Lazy)": {
    "prefix": "segment_tree",
    "body": [
      "class SegmentTree {",
      "  public:",
      "    int* arr;",
      "    ${1:int} val;",
      "    ${1:int} lazy_val;",
      "    bool lazy_status;",
      "    ",
      "    SegmentTree *left, *right;",
      "    int seg_start, seg_end;",
      "",
      "    /*  Constructor",
      "      *   Build complete segment tree.",
      "      *",
      "      *   @param (data_type) *a: target list",
      "      *   @param int start: inclusive starting index of a",
      "      *   @param int end: inclusive ending index of a",
      "    */",
      "    SegmentTree(${1:int}* a, int start, int end) {",
      "      arr = a;",
      "      seg_start = start;",
      "      seg_end = end;",
      "      left = NULL;",
      "      right = NULL;",
      "      ",
      "      if(start==end) {",
      "        val = arr[start];",
      "        return;",
      "      }",
      "",
      "      int mid = start + (end-start)/2;",
      "      left = new SegmentTree(arr, start, mid);",
      "      right = new SegmentTree(arr, mid+1, end);",
      "",
      "      val = process_node(left->val, right->val);",
      "      lazy_status = false;",
      "    }",
      "",
      "    /*  Node value processor.",
      "      *  Operates of children nodes' values",
      "      *  and updates current node's value.",
      "      *",
      "      *  @param (data_type) left_val: value of left child",
      "      *  @param (data_type) right_val: value of right child",
      "      *  @return (data_type): processed value of children",
      "    */",
      "    ${1:int} process_node(${1:int} left_val, ${1:int} right_val) {",
      "      return  ${2:min(left_val, right_val);}",
      "    }",
      "",
      "    /* Query operation.",
      "      *  Uses process_node to evaluate value of specified range.",
      "      * ",
      "      *  @param int query_start: inclusive starting index of target range",
      "      *  @param int query_end: inclusive ending index of target range",
      "      *  @return (data_type): process value of target range",
      "    */",
      "    ${1:int} query(int query_start, int query_end) {",
      "      if(lazy_status)",
      "        propogate();",
      "",
      "      if(is_total_overlap(query_start, query_end)) {",
      "        return val;",
      "      } else if(is_partial_overlap(query_start, query_end)) {",
      "          int left_val = left->query(query_start, query_end);",
      "          int right_val = right->query(query_start, query_end);",
      "          return process_node(left_val, right_val);",
      "      }",
      "",
      "      return 1000000000;",
      "    }",
      "",
      "    ",
      "    /* Update operation.",
      "      *  Uses lazy_update to update the current subtree.",
      "      *",
      "      *  @param (data_type) update_val",
      "      *  @param int query_start: inclusive starting index of target range",
      "      *  @param int query_end: inclusive ending index of target range",
      "    */",
      "    void update(${1:int} update_val, int query_start, int query_end) {",
      "      if(lazy_status)",
      "        propogate();",
      "",
      "      if(is_total_overlap(query_start, query_end)) {",
      "        lazy_update(update_val);",
      "      } else if(is_partial_overlap(query_start, query_end)) {",
      "          left->update(update_val, query_start, query_end);",
      "          right->update(update_val, query_start, query_end);",
      "      }",
      "    }",
      "",
      "    void propogate() {",
      "      left->lazy_update(lazy_val);",
      "      right->lazy_update(lazy_val);",
      "      lazy_status = false;",
      "    }",
      "",
      "    void lazy_update(${1:int} update_val) {",
      "      ${3:val += update_val;}",
      "",
      "      if(left != NULL) ",
      "        left->set_lazy(update_val);",
      "      if(right != NULL) ",
      "        right->set_lazy(update_val);",
      "    }",
      "",
      "    void set_lazy(${1:int} update_val) {",
      "      lazy_val += update_val;",
      "      lazy_status = true;",
      "    }",
      "",
      "    bool is_total_overlap(int query_start, int query_end) {",
      "      return query_start<=seg_start && seg_end<=query_end;",
      "    }",
      "",
      "    bool is_partial_overlap(int query_start, int query_end) {",
      "      return !(query_end<seg_start || query_start>seg_end);",
      "    }",
      "};"
    ],
    "description": "Creates Segment Tree with Lazy Propogation"
  }
}
